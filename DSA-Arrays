//73. Set Matrix Zeroes

class Solution {
public:
 void setZeroes(vector<vector<int>> & matrix){
bool firstRow = false, firstCol = false;
int m = matrix.size(), n = matrix[0].size();

for(int i =0; i< m ; i++){
    for(int j =0; j<n; j++){
      if(matrix[i][j] == 0){
              if( i  == 0 ) firstRow = true;
              if( j == 0 ) firstCol = true;
              matrix[0][j] = 0;
              matrix[i][0] = 0;
          }
      }
}
for(int i = 1; i< m; i++){
  for(int j = 1; j< n ;j++){
    if( matrix[i][0] == 0 || matrix[0][j] == 0){
        matrix[i][j] = 0;
    }
}
}

if(firstRow){
 for(int j =0; j<n; j++){
matrix[0][j] = 0;
}
}
if(firstCol){
for(int i =0; i<m; i++){
matrix[i][0] = 0;
}
}
}
};


ðŸ‘‘56. Merge Intervals


vector<vector<int>> merge(const vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};

    vector<vector<int>> sorted = intervals;
    sort(sorted.begin(), sorted.end()); // Sort by start time

    vector<vector<int>> merged;
    merged.push_back(sorted[0]);

    for (int i = 1; i < sorted.size(); ++i) {
        if (sorted[i][0] <= merged.back()[1]) {
            // Overlap: merge intervals
            merged.back()[1] = max(merged.back()[1], sorted[i][1]);
        } else {
            merged.push_back(sorted[i]);
        }
    }

    return merged;
}


ðŸ”¥ 2105. Watering Plants II

class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int canA = capacityA, canB = capacityB;
        int i = 0, j = plants.size() - 1;
        int refillA = 0, refillB = 0;

        while (i < j) {
            if (canA < plants[i]) {
                refillA++;
                canA = capacityA;
            }
            if (canB < plants[j]) {
                refillB++;
                canB = capacityB;
            }
            canA -= plants[i];
            canB -= plants[j];
            i++;
            j--;
        }

        // If there's a middle plant
        if (i == j) {
            if (canA < plants[i] && canB < plants[i]) {
                refillA++; // Alice has priority
            }
        }

        return refillA + refillB;
    }
};

ðŸ”¥ Leetcode 219. Contains Duplicate II â€” Hash Map + Index Tracking Approach
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> lastseenindex;

        for (int i = 0; i < nums.size(); ++i) {
            if (lastseenindex.find(nums[i]) != lastseenindex.end()) {
                if (i - lastseenindex[nums[i]] <= k) {
                    return true;
                }
            }

            // Update the index of the current element
            lastseenindex[nums[i]] = i;
        }

        return false; // No such pair found
    }
};

ðŸ”¥Missing number in an array 

#include <iostream>
using namespace std;

int findMissingNumber(int arr[], int n) {
    int hash[n+1] = {0};  // Initialize hash array of size n+1 with 0

    // Mark all present numbers in the hash array
    for (int i = 0; i < n; i++) {
        hash[arr[i]] = 1;
    }

    // Find the number which is missing (whose hash value is 0)
    for (int i = 0; i <= n; i++) {
        if (hash[i] == 0) {
            return i;
        }
    }

    return -1;  // If nothing is missing
}


ðŸ”¥


#include <iostream>
using namespace std;

int findMissingNumber(int arr[], int n) {
    int xor1 = 0, xor2 = 0;

    // XOR all natural numbers from 1 to n
    for (int i = 1; i <= n; i++) {
        xor1 ^= i;
    }

    // XOR all elements in the array
    for (int i = 0; i < n - 1; i++) {
        xor2 ^= arr[i];
    }

    // XOR of the two gives the missing number
    return xor1 ^ xor2;
}

int main() {
    int arr[] = {1, 2, 4, 5}; // Missing number is 3
    int n = 5; // Total numbers should be from 1 to 5

    cout << "Missing Number: " << findMissingNumber(arr, n) << endl;

    return 0;
}

ðŸ”¥167. Two Sum II - Input Array Is Sorted
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i = 0 ;
        int j = numbers.size() - 1;
           
            while(i < j){
                int sum = numbers[i] + numbers[j];
            if( sum < target){
                i++;
            }else if(sum > target){
                j--;
                }else{
                    
                    return {i+1, j+1};
              } 
        }
        return {};
    }
};
ðŸ˜‡ 345. Reverse Vowels of a String
class Solution {
public:

        bool isVowel(char &ch){
        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
   }
    string reverseVowels(string s) {
        int n = s.length();
        int i = 0;
        int j = n -1;
    
        while(i < j){
            if ( !isVowel(s[i])) i++;

            else if(!isVowel(s[j])) j--;

            else{
                swap(s[i], s[j]);
                i++;
                j--;
            }
        }
        return s;
    }
};
ðŸ”¥1207. Unique Number of Occurrences
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int, int> count;

        // Count frequency of each element
        for (int x : arr) {
            count[x]++;
        }

        unordered_set<int> st;

        // Check if any frequency is repeated
        for (auto& it : count) {
            int freq = it.second;
            if (st.find(freq) != st.end()) {
                return false;
            }
            st.insert(freq);
        }

        return true;
    }
};


ðŸ˜Ž2225. Find Players With Zero or One Losses
class Solution {
public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        unordered_map<int, int> lost_map;
        for(int i = 0 ; i< matches.size(); i++){
            int loser = matches[i][1];
            lost_map[loser]++;
        }
        
        vector<int> notLost;
        vector<int> lostOnce;

        for (int i = 0; i < matches.size(); i++) {
            int winner = matches[i][0];
            int loser = matches[i][1];

            if (lost_map.find(winner) == lost_map.end()) {
                notLost.push_back(winner);
                lost_map[winner] = 2; // Marked to avoid duplicates
            }

            if (lost_map[loser] == 1) {
                lostOnce.push_back(loser);
                lost_map[loser] = 2; // Marked to avoid duplicates
            }
        }

        sort(begin(notLost), end(notLost));
        sort(begin(lostOnce), end(lostOnce));

        return {notLost, lostOnce};
    }
};

ðŸ”¥1512. Number of Good Pairs
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int result = 0;
        unordered_map<int , int > store;

        for(int &num : nums){

            result += store[num];

            store[num]++;

        }

        return result;
    }
};















